%=========================================================================
% (c) Michal Bidlo, Bohuslav KÅ™ena, 2008

% tikzit regex: (,)?\s*style=\w*(,)?\s*

% \listoftodos

\chapter{Introduction}
Nowadays, when malicious code or malware is becoming more and more sophisticated and pressing security risk, it is really needed to control a program behaviour and monitor what the program is doing in a system.
Monitoring program behaviour can be done in many ways and one of the easiest ways is to use Intrusion Detection System (IDS).
IDS is an out-of-the-box solution which can monitor i.e. where program wrote or read something and it is not allowed.
After that, IDS is reporting this violation.

Another way is to monitor and block system calls (syscalls).
Monitoring is performed using tools mentioned in the next chapter.
The actual blocking can be performed with mandatory control access (MAC) (Apparmor, SELinux), sandboxing (seccomp) or others mechanisms.
MAC refers to a type of access control by which the operating system constraints the ability of a subject or initiator to access or generally perform some sort of operation on an object or target.
Seccomp is a Linux kernel module which allows to a process one-way transition to secure a state where the process can only use four syscalls.
When the process tries to call another syscall then one of the four members set is terminated with SIGKILL.
The set of allowed system calls can be extended using seccomp-bpf.
This extension allows filtering system calls using a configurable policy implemented with Berkley Packet Filter (BPF) rules.
This last part is an area on which I would like to focus in my thesis.

I aim to design and develop a tool which helps developers using libseccomp and seccomp-bpf.
I plan to create policies for a specific program in a format readable by libseccomp or seccomp-bpf.

\Cref{chap:syscalls} describes syscalls and how to monitor them.
In the next chapter of the thesis, I will illustrate how security facilities in Linux, such as systrace and seccomp, work.
After the theoretical part, the design and development of a tool will follow.
In conclusion, methodology how this tool was tested is described.

\chapter{System calls and tools monitoring them}
\label{chap:syscalls}
In this chapter, I will describe a term system call and I will make an overview of tools which can monitor the system calls.
We will red focus in detail on a strace tool which will be used as an input to my tool.
The other tools are described briefly not as detailed as strace.

\section{System calls}

In computer terminology, the term syscall is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on.
In other words, the system calls are functions used in the kernel itself.
To the programmer, the system call appears as a normal C function call.
This is typical for monolithic kernels and we can find them on every UNIX system.
The system calls are generated using interrupt i.e. on Linux/i86 with interrupt no. \texttt{0x80} and these syscalls are handled by the kernel in privileged mode.
When a user invokes a system call, execution flow is as follows:
\begin{itemize}
	%\item Each call is vectored through a stub in libc. Some system calls are more complex than others because of variable length of arguments. But every syscall has the same entry point and the same exit point. Only overhead in more complex syscalls is processing more parameters on entry.
	%\item Each syscall is expanded to assembly routine. This routine also sets up the stack frame and calls \texttt{\_system\_call\(\)} through an interrupt \( \texttt{int \$0x80} \).
	%\item There was not executed any code of syscall. Not until int \texttt{\$0x80} is executed, this interrupt does the call transfer to the kernel entry point. The entry point is the same for every system call. Now is saved the state of central process unit (CPU), saved all of the registers, checked if is valid syscall called. Transfering control to a valid syscall is done through the offset in the \texttt{\_sys\_call\_table}.
	%\item At the end of the syscall is called \texttt{\_ret\_from\_sys\_call\(\)}. This is done before returning to user space. It checks if the scheduler should be run, and if so, calls it.
	%\item Immediately after return from the system call, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.

	% \todo{Decide which one}
	% \missingfigure{Make a sketch of the calling a syscall}

	\item Each syscall is vectored through a stub in libc. Some syscalls are more complex than others because of variable length of arguments, but the entry point and end point of syscall is still the same. Only overhead is processing more arguments.
	\item In libc is then set the number of the syscall to \texttt{eax} register and the stack frame is also set up.
	\item Interrupt number \texttt{0x80} is called and transfered to kernel entry point. The entry point is the same for every system call.
	\item In table of interrupts is found a pointer to interrupt handler. After that follows the execution of the interrupt handler. Now in the handler is stored the content of the CPU registers, checked if is valid syscall called.
	\item The handler finds the corresponding offset in table of interrupts \texttt{\_sys\_call\_table}, where is stored pointer to syscall service.
	\item Control is transfered to the syscall service.
	\item Syscall returned return value to register \texttt{EAX} on 32-bit architecture or \texttt{RAX} on 64-bit architecture.
	\item At the end of the syscall is called \texttt{\_ret\_from\_sys\_call\(\)}. This is done before returning to user space. It checks if the scheduler should be run, and if so, calls it.
	\item Immediately after return from the system call to interrupt handler, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.
\end{itemize}

This procedure is illustrated in figure \ref{fig:tikz:int_handling} on page \pageref{fig:tikz:int_handling}.

\begin{figure}[]
  \centering
  % \includestandalone[]{obrazky-figures/mytikz}%     without .tex extension
  \input{obrazky-figures/mytikz}
  \caption{Interrupt handling in Linux}
  \label{fig:tikz:int_handling}
\end{figure}


\section{Monitoring}
The most used and common method for monitoring is tracing, in other words watching what a program is doing during the execution.
Tracing involves a specialized logging to record information, useful for debugging, about a program's execution.
This can be done in multiple layers, from tracing which lines in the program was executed to individual instructions executed on CPU.
Collecting this information can be done with multiple tools i.e strace, ftrace and a lots of more.

\subsection{Strace -- trace system calls and signals}

Strace\cite{strace_man} is a simple diagnostic, instructional and debugging tool.
You can monitor every syscall or signal made by the program you are monitoring.
So with this tool is possible to log what observed program demanded from the kernel.
The individual logged operations can be i.e. an attempt to open a file or delete the content of CPU caches.
Strace also shows arguments for the called syscall.
As well you can perform a fault injection for the specified set of syscalls, to simulate program in faulty test cases.
Next feature is that the strace can trace child processes of the observing program.
So the log on the output will be containing the syscalls from the main process and its child processes.

The main advantage of Strace tool is that it does not need any source codes.
The observing program hasn't to be compiled with extra flags nor object files.
Also, it doesn't matter if the program is statically or dynamically linked.
This is really useful because we only need executable binary.
These features are really useful for mine tool but this will be more described in another chapter.

This tool is really simple i.e. when you want to run \texttt{ls} with strace you type in command line:\\
\\
\texttt{>\$ strace ls}\\
\\
In this case, the strace executes the \texttt{ls} command and on the output occurs which system calls were called.
Example of the strace output is in next figure.\\[2mm]

\fontfamily{lmtt}\selectfont\noindent
execve("/usr/bin/ls", ["ls"], 0x7ffd0cf4ba60 /* 59 vars */) = 0\linebreak
open("/etc/ld.so.cache", O\_RDONLY|O\_CLOEXEC) = 3\linebreak
fstat(3, $\{$ st\_mode=S\_IFREG|0644, st\_size=202163, ...$\}$) = 0\linebreak
mmap(NULL, 202163, PROT\_READ, MAP\_PRIVATE, 3, 0) = 0x7fd781293000\linebreak
close(3)\linebreak
\fontfamily{\familydefault}\selectfont

\subsubsection{Ptrace}
Strace is using ptrace\cite{ptrace_man} system call.
The ptrace is used to  implement debuggers and other tools for process monitoring.
Basically the strace call ptrace and attach to a tracee (monitored process).
When the connection is established the tracee is halt before and after syscall.
Now the tracer (strace) can observe and control the execution as well as inspect memory and registers of (tracee).
With this information strace can determine which syscall was called.
With the second halt after syscall, the strace can get information of return value from syscall.

\subsection{Ftrace -- trace system calls, function calls and signals}
Ftrace\cite{ftrace_man} is an internal tracer which traces events in kernel.
It is designed for developers to examine kernel events. 
Main feature of this tool is to measure latencies and find issues that takes place outside of the user-space.
Ftrace is typically considered as a function tracker, but it is really a frame work of several different tracing utilities.
One cool feature of ftrace is measurement latency among interrupts, latency between the time when task is woken up and time when the task is scheduled in.
Other common use of ftrace is event tracing.
In the kernel is a huge amount of static event points that can be enabled with tracefs file system. 
The event points provide a interface to observe what is going on in the various part of kernel.

\subsection{Dtrace -- Dynamic Tracing}
DTrace\cite{dtrace_man}\cite{dtrace_about} (shortcut for Dynamic Tracing) is a performance analysis and troubleshooting tool.
It is included in a various operating system, including FreeBSD, Mac OS, Solaris and Linux port is in development.
This tool instruments all software.
Not just user-level software but also operating system kernel and device drivers.
Supports the dynamic tracing which means dynamically patching while running instructions with instrumentation code.
Static tracing is as well supported but it needs to add tracepoints to code.
DTrace provides a scripting language called 'D', for writing scripts and one-liners.
It is similar to C with AWK elements.
With this script, you can create filters and you can summarize data in the kernel before passing to user-space.
This design can really decrease the overhead in performance sensitive systems.

For our purposes, DTrace is too complicated to setup or gather the information about syscalls.
You need to write some scripts to define which syscalls you want to be informed with and in our use case, we need every system call.

\subsection{Autrace -- linux audit}
The Linux Auditing System helps system administrators create an audit trail.
Every action on workstation or server is logged into log file.
This tool can track security relevant events, record the events and detect misuse or unauthorized activities by inspecting the audit log.
You can also set which actions should or should not be reported. 

Audit System is composed of two main parts.
The first one \(autrace\) is kernel component which intercept system calls, records event and sends these audit messages to the next part.
The second component is audit daemon.
This part of this tool is collecting the information emitted by kernel component.
Emitted information are then stored as entries in a log file.

As you can see this tool is not for monitoring one specific program but it is designed to monitor whole system.
In the output is specified who executed the syscall and when, next are current working directory, uid, gid, etc., \ldots
%Above specified functionality is useful for server administrators but not for our work.

Entry example in log file:

\noindent
\texttt{type=SYSCALL msg=audit(1434371271.277:135496): arch=c000003e syscall=2}\linebreak
\texttt{success=yes exit=3 a0=7fff0054e929 a1=0 a2=1fffffffffff0000 a3=7fff0054c390 }\linebreak
\texttt{items=1 ppid=6265pid=6266 auid=1000 uid=0 gid=0 euid=0 suid=0 fsuid=0 }\linebreak
\texttt{egid=0 sgid=0 fsgid=0 tty=pts0 ses=113 comm="cat" }\linebreak
\texttt{exe="/usr/bin/cat" key="sshconfigchange"}



\chapter{Security facility in Linux}
Systrace\cite{systrace_web} and seccomp\cite{seccomp_sandbox}

\section{Systrace}
Systrace is security facility which limits an application's access to the system

\section{Seccomp}
In most contemporary distribution is enabled kernel module named Seccomp\cite{seccomp_sandbox}.
Seccomp stands for shortcut of Secure Computing Mode.
This module provide one way transition to a secure mode, which restricts a thread to a small amount of system calls \( \texttt{read()},\ \texttt{write()},\ \texttt{exit()},\ \texttt{sigreturn()}\ \).
If the thread tries to call other system call then the one from the 4 member set, the whole process is terminated with signal \texttt{SIGTERM}. 
The drawback of this solution is that these four system calls are not enough for application to run correctly.

\subsection{Seccomp-bpf}
\subsubsection{Berkeley packet filter}
\subsubsection{Classic BPF}
\subsubsection{Extended BPF}

\subsection{libseccomp}



\chapter{Design of TODO: tool-name}
\section{parser}
\section{optimizer}
\section{translator}



\chapter{Development of TODO: tool-name}
\section{Input}
\section{Intermediate representation}
\section{Output}
\section{Heuristics and optimizations}
\subsection{Minimax}
\subsection{Strict}
\subsection{Smart}


\chapter{Testing methods}


%=========================================================================
