%=========================================================================
% (c) Michal Bidlo, Bohuslav KÅ™ena, 2008

% tikzit regex: (,)?\s*style=\w*(,)?\s*

% \listoftodos

\chapter{Introduction}
Nowadays, when malicious code or malware is becoming more and more sophisticated and pressing security risk, it is really needed to control a program behaviour and monitor what the program is doing in a system.
Monitoring program behaviour can be done in many ways and one of the easiest ways is to use Intrusion Detection System (IDS).
IDS is an out-of-the-box solution which can monitor i.e. where program wrote or read something and it is not allowed.
After that, IDS is reporting this violation.

Another way is to monitor and block system calls (syscalls).
Monitoring is performed using tools mentioned in the next chapter.
The actual blocking can be performed with mandatory control access (MAC) (Apparmor, SELinux), sandboxing (seccomp) or others mechanisms.
MAC refers to a type of access control by which the operating system constraints the ability of a subject or initiator to access or generally perform some sort of operation on an object or target.
Seccomp is a Linux kernel module which allows to a process one-way transition to secure a state where the process can only use four syscalls.
When the process tries to call another syscall then one of the four members set is terminated with SIGKILL.
The set of allowed system calls can be extended using seccomp-bpf.
This extension allows filtering system calls using a configurable policy implemented with Berkley Packet Filter (BPF) rules.
This last part is an area on which I would like to focus in my thesis.

I aim to design and develop a tool which helps developers using libseccomp and seccomp-bpf.
I plan to create policies for a specific program in a format readable by libseccomp or seccomp-bpf.

\Cref{chap:syscalls} describes syscalls and how to monitor them.
In the next chapter of the thesis, I will illustrate how security facilities in Linux, such as systrace and seccomp, work.
After the theoretical part, the design and development of a tool will follow.
In conclusion, methodology how this tool was tested is described.

\chapter{System calls and tools monitoring them}
\label{chap:syscalls}
In this chapter, I will describe a term system call and I will make an overview of tools which can monitor the system calls.
We will red focus in detail on a strace tool which will be used as an input to my tool.
The other tools are described briefly not as detailed as strace.

\section{System calls}

In computer terminology, the term syscall is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on.
In other words, the system calls are functions used in the kernel itself.
To the programmer, the system call appears as a normal C function call.
This is typical for monolithic kernels and we can find them on every UNIX system.
The system calls are generated using interrupt i.e. on Linux/i86 with interrupt no. \texttt{0x80} and these syscalls are handled by the kernel in privileged mode.
When a user invokes a system call, execution flow is as follows:
\begin{itemize}
	%\item Each call is vectored through a stub in libc. Some system calls are more complex than others because of variable length of arguments. But every syscall has the same entry point and the same exit point. Only overhead in more complex syscalls is processing more parameters on entry.
	%\item Each syscall is expanded to assembly routine. This routine also sets up the stack frame and calls \texttt{\_system\_call\(\)} through an interrupt \( \texttt{int \$0x80} \).
	%\item There was not executed any code of syscall. Not until int \texttt{\$0x80} is executed, this interrupt does the call transfer to the kernel entry point. The entry point is the same for every system call. Now is saved the state of central process unit (CPU), saved all of the registers, checked if is valid syscall called. Transfering control to a valid syscall is done through the offset in the \texttt{\_sys\_call\_table}.
	%\item At the end of the syscall is called \texttt{\_ret\_from\_sys\_call\(\)}. This is done before returning to user space. It checks if the scheduler should be run, and if so, calls it.
	%\item Immediately after return from the system call, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.

	% \todo{Decide which one}
	% \missingfigure{Make a sketch of the calling a syscall}

	\item Each syscall is vectored through a stub in libc. Some syscalls are more complex than others because of variable length of arguments, but the entry point and end point of syscall is still the same. Only overhead is processing more arguments.
	\item In libc is then set the number of the syscall to \texttt{eax} register and the stack frame is also set up.
	\item Interrupt number \texttt{0x80} is called and transfered to kernel entry point. The entry point is the same for every system call.
	\item In table of interrupts is found a pointer to interrupt handler. After that follows the execution of the interrupt handler. Now in the handler is stored the content of the CPU registers, checked if is valid syscall called.
	\item The handler finds the corresponding offset in table of interrupts \texttt{\_sys\_call\_table}, where is stored pointer to syscall service.
	\item Control is transfered to the syscall service.
	\item Syscall returned return value to register \texttt{EAX} on 32-bit architecture or \texttt{RAX} on 64-bit architecture.
	\item At the end of the syscall is called \texttt{\_ret\_from\_sys\_call\(\)}. This is done before returning to user space. It checks if the scheduler should be run, and if so, calls it.
	\item Immediately after return from the system call to interrupt handler, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.
\end{itemize}

This procedure is illustrated in figure \ref{fig:tikz:int_handling} on page \pageref{fig:tikz:int_handling}.

\begin{figure}[]
  \centering
  % \includestandalone[]{obrazky-figures/mytikz}%     without .tex extension
  \input{obrazky-figures/mytikz}
  \caption{Interrupt handling in Linux}
  \label{fig:tikz:int_handling}
\end{figure}

\todo{Make description to the above figure \ldots}

% \input{obrazky-figures/Diagram1.tex}

\section{Monitoring}
The most used and common method for monitoring is tracing, in other words watching what a program is doing during the execution.
Tracing involves a specialized logging to record information, useful for debugging, about a program's execution.
This can be done in multiple layers, from tracing which lines in the program was executed to individual instructions executed on CPU.
Collecting this information can be done with multiple tools i.e strace, ftrace and a lots of more.

\subsection{Strace -- trace system calls and signals}

Strace is a simple diagnostic, instructional and debugging tool.
You can monitor every syscall or signal made by the program you are monitoring.
So with this tool is possible to log what observed program demanded from the kernel.
The individual logged operations can be i.e. an attempt to open a file or delete the content of CPU caches.
Strace also shows arguments for the called syscall.
As well you can perform a fault injection for the specified set of syscalls, to simulate program in faulty test cases.
Next feature is that the strace can trace child processes of the observing program.
So the log on the output will be containing the syscalls from the main process and its child processes.

The main advantage of Strace tool is that it does not need any source codes.
The observing program hasn't to be compiled with extra flags nor object files.
Also, it doesn't matter if the program is statically or dynamically linked.
This is really useful because we only need executable binary.
These features are really useful for mine tool but this will be more described in another chapter.

This tool is really simple i.e. when you want to run \texttt{ls} with strace you type in command line:\\
\texttt{>\$ strace ls}

In this case, the strace executes the \texttt{ls} command and on the output occurs which system calls were called.
Example of the strace output is in next figure. \todo{Add here the small output}

\subsection{Ftrace -- trace system calls, function calls and signals}

\subsection{Ltrace}
\subsection{Dtrace}
DTrace (shortcut for Dynamic Tracing) is a performance analysis and troubleshooting tool.
It is included in a various operating system, including FreeBSD, Mac OS, Solaris and Linux port is in development.
This tool instruments all software. Not just user-level software but also operating system kernel and device drivers.
Supports the dynamic tracing which means dynamically patching while running instructions with instrumentation code.
Static tracing is as well supported but it needs to add tracepoints to code.
DTrace provides a scripting language called 'D', for writing scripts and one-liners.
It is similar to C with AWK elements.
With this script, you can create filters and you can summarize data in the kernel before passing to user-space.
This design can really decrease the overhead in performance sensitive systems.

For our purposes, DTrace is too complicated to setup or gather the information about syscalls. You need to write some scripts to define which syscalls you want to be informed and in our use case, we need every syscall.

\subsection{Autrace -- linux audit}

\chapter{Security facility in Linux}
Systrace and seccomp\cite{Pravidla}
\section{Systrace}
123

\section{Seccomp}
321
% \missingfigure{Strace output}
\subsection{Seccomp-bpf}

\subsection{Berkeley packet filter}
\subsubsection{Classic BPF}
\subsubsection{Extended BPF}

\subsection{libseccomp}


\chapter{Development of TODO: tool-name}
\section{Input}
\section{Intermediate representation}
\section{Output}
\section{Heuristics and optimizations}
\subsection{Minimax}
\subsection{Strict}
\subsection{Smart}


\chapter{Testing methods}


%=========================================================================
