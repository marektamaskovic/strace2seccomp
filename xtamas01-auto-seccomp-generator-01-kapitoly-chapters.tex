%=========================================================================
% (c) Michal Bidlo, Bohuslav KÅ™ena, 2008

\listoftodos

\chapter{Introduction}
Nowadays, when malicious code or malware is becoming more and more sophisticated and pressing security risk, it is really needed to control a program behaviour and monitor what the program is doing in a system.
Monitoring program behaviour can be done in many ways and one of the easiest ways is to use Intrusion Detection System (IDS).
IDS is an out-of-the-box solution which can monitor i.e. where program wrote or read something and it is not allowed.
After that, IDS is reporting this violation. %TODO and and

Another way is to monitor and block system calls (syscalls).
Monitoring is performed using tools mentioned in the next chapter.
The actual blocking can be performed with mandatory control access (MAC) (Apparmor, SELinux), sandboxing (seccomp) or others mechanisms.
MAC refers to a type of access control by which the operating system constraints the ability of a subject or initiator to access or generally perform some sort of operation on an object or target.
Seccomp is a Linux kernel module which allows to a process one-way transition to secure a state where the process can only use four syscalls.
When the process tries to call another syscall then one of the four members set is terminated with SIGKILL.
The set of allowed system calls can be extended using seccomp-bpf.
This extension allows filtering system calls using a configurable policy implemented with Berkley Packet Filter (BPF) rules.
This last part is an area on which I would like to focus in my thesis.

I aim to design and develop a tool which helps developers using libseccomp and seccomp-bpf.
I plan to create policies for a specific program in a format readable by libseccomp or seccomp-bpf.

\Cref{chap:syscalls} describes syscalls and how to monitor them.
In the next chapter of the thesis, I will illustrate how security facilities in Linux, such as systrace and seccomp, work.
After the theoretical part, the design and development of a tool will follow.
In conclusion, methodology how this tool was tested is described.

\chapter{System calls and tools monitoring them}
\label{chap:syscalls}
In this chapter, I will describe a term system call and I will make an overview of tools which can monitor the system calls.
We will red focus in detail on a strace tool which will be used as an input to my tool.
The other tools are described briefly not as detailed as strace.

\section{System calls}
System calls or syscalls is a mechanism used by processes to use operating system functions typically in monolithic kernels.
We can find them on every UNIX system.
In computer terminology, the term syscall is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on. The system calls are generated using interrupt i.e. on Linux/i86 with interrupt no. \texttt{0x80}. and these syscalls are handled by the kernel in privileged mode.
When a user invokes a system call, execution flow is as follows:
\begin{itemize}
	\item Each call is vectored through a stub in libc. Some system calls are more complex than others because of variable length of arguments. But every syscall has the same entry point and the same exit point. Only overhead in more complex syscalls is processing more parameters on entry.
	\item Each syscall is expanded to assembly routine. This routine also sets up the stack frame and calls \texttt{\_system\_call\(\)} through an interrupt \( \texttt{int \$0x80} \).
	\item There was not executed any code of syscall. Not until int \texttt{\$0x80} is executed, this interrupt does the call transfer to the kernel entry point. The entry point is the same for every system call. Now is saved the state of central process unit (CPU), saved all of the registers, checked if is valid syscall called. Transfering control to a valid syscall is done through the offset in the \texttt{\_sys\_call\_table}.
	\item At the end of the syscall is called \texttt{\_ret\_from\_sys\_call\(\)}. This is done before returning to user space. It checks if the scheduler should be run, and if so, calls it.
	\item Immediately after return from the system call, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.

	\todo{Decide which one}

	\item Each syscall is vectored through a stub in libc. Some syscalls are more complex than others because of variable length of arguments, but the entry point and end point of syscall is still the same. Only overhead is processing more arguments.
	\item In libc is then set the number of the syscall to \texttt{eax} register and the stack frame is also set up.
	\item Interrupt number \texttt{0x80} is called and transfered to kernel entry point. The entry point is the same for every system call.
	\item In table of interrupts is found a pointer to interrupt handler. After that follows the execution of the interrupt handler. Now in the handler is stored the content of the CPU registers, checked if is valid syscall called.
	\item The handler finds the corresponding offset in table of interrupts \texttt{\_sys\_call\_table}, where is stored pointer to syscall service.
	\item Control is transfered to the syscall service.
	\item Syscall returned return value to register \texttt{EAX} on 32-bit architecture or \texttt{RAX} on 64-bit architecture.
	\item At the end of the syscall is called \texttt{\_ret\_from\_sys\_call\(\)}. This is done before returning to user space. It checks if the scheduler should be run, and if so, calls it.
	\item Immediately after return from the system call to interrupt handler, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.
\end{itemize}

\missingfigure{Make a sketch of the calling a syscall}
\todo[color=green, inline]{Make description to the above figure \ldots}
% \input{obrazky-figures/Diagram1.tex}

\section{Monitoring}
The most used method for monitoring is tracing, in other words watching what a program is doing. Tracing involves a specialized logging to record information, useful for debugging, about a program's execution. This can be done in multiple layers, from tracing which lines in the program was executed to individual instructions executed on CPU. Collecting of this information can be done with multiple tools i.e strace, ftrace and a lot more.

\subsection{Strace -- trace system calls and signals}
\subsection{Ftrace -- trace system calls, function calls and signals}
\subsection{Ltrace}
\subsection{Dtrace}
\subsection{Autrace -- linux audit}

\chapter{Security facility in Linux}
Systrace and seccomp\cite{Pravidla}
\section{Systrace}
123

\section{Seccomp}
321
\subsection{Seccomp-bpf}

\subsection{Berkeley packet filter}
\subsubsection{Classic BPF}
\subsubsection{Extended BPF}

\subsection{libseccomp}


\chapter{Development of TODO: tool-name}
\section{Input}
\section{Intermediate representation}
\section{Output}
\section{Heuristics and optimizations}
\subsection{Minimax}
\subsection{Strict}
\subsection{Smart}


\chapter{Testing methods}


%=========================================================================
