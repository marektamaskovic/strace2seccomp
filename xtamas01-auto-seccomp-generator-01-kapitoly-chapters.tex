%=========================================================================
% (c) Michal Bidlo, Bohuslav KÅ™ena, 2008

% tikzit regex: (,)?\s*style=\w*(,)?\s*

% \listoftodos

\chapter{Introduction}
Nowadays, when malicious code or malware is becoming more and more sophisticated and pressing security risk, it is really needed to control a program behaviour and monitor what the program is doing in a system.
Monitoring program behaviour can be done in many ways and one of the easiest ways is to use Intrusion Detection System (IDS).
IDS is an out-of-the-box solution which can monitor i.e. where program wrote or read something and it is not allowed.
After that, IDS is reporting this violation.

Another way is to monitor and block system calls (syscalls).
Monitoring is performed using tools mentioned in the next chapter.
The actual blocking can be performed with mandatory control access (MAC) (Apparmor, SELinux), sandboxing (seccomp) or others mechanisms.
MAC refers to a type of access control by which the operating system constraints the ability of a subject or initiator to access or generally perform some sort of operation on an object or target.
Seccomp is a Linux kernel module which allows to a process one-way transition to secure a state where the process can only use four syscalls.
When the process tries to call another syscall then one of the four members set is terminated with SIGKILL.
The set of allowed system calls can be extended using seccomp-bpf.
This extension allows filtering system calls using a configurable policy implemented with Berkley Packet Filter (BPF) rules.
This last part is an area on which I would like to focus in my thesis.

I aim to design and develop a tool which helps developers using libseccomp and seccomp-bpf.
I plan to create policies for a specific program in a format readable by libseccomp or seccomp-bpf.

\Cref{chap:syscalls} describes syscalls and how to monitor them.
In the next chapter of the thesis, I will illustrate how security facilities in Linux, such as systrace and seccomp, work.
After the theoretical part, the design and development of a tool will follow.
In conclusion, methodology how this tool was tested is described.

\chapter{System calls and tools monitoring them}
\label{chap:syscalls}
In this chapter, I will describe a term system call and make an overview of tools which can monitor the system calls.
We will focus in detail on a strace tool which will be used as an input to my tool.
The other tools are described briefly not as detailed as the strace tool.

\section{System calls}

In computer terminology, the term syscall is a programmatic way in which a computer program requests a service from a kernel of the operating system on which is executed on.
In other words, the system calls are functions used in the kernel itself.
The system call appears to a standard developer as a C function call.
This is typical for monolithic kernels.
We can find them on every UNIX system.
The system calls are generated using interrupt, i.e., on Linux/i86 with an interrupt no. \texttt{0x80} and these syscalls are handled by the kernel in a privileged mode.
When a user invokes a system call, an execution flow is as follows:
\begin{itemize}
	\item Each syscall is vectored through a stub in libc.
    		Some syscalls are more complex than others because of a variable length of the arguments, but the entry point and end point of syscall is still the same.
	\item In libc, the number of the syscall is then set to an \texttt{eax} register and the stack frame is also set up.
	\item An interrupt number \texttt{0x80} is called and transfered to the kernel entry point.
    		The entry point is the same for every system call.
	\item In table of interrupts, a pointer to interrupt handler is found. After that the execution of the interrupt handler follows.
    		Now in the handler, the content of the CPU registers is stored and checked if a valid syscall is called.
	\item The handler finds the corresponding offset in the table of interrupts \texttt{\_sys\_call\_table}, where pointer to syscall service is stored.
	\item Control is transfered to the syscall service.
	\item Syscall returns a value to the register \texttt{EAX} on 32-bit architecture or \texttt{RAX} on 64-bit architecture.
	\item At the end of the syscall, \texttt{\_ret\_from\_sys\_call\(\)} is called.
    		This is done before returning to user space. It checks if the scheduler should be run, and if so, it calls it.
	\item Immediately after return from the system call to interrupt handler, \texttt{syscallX()} macro checks for a negative return value from the syscall, if so it puts a positive copy to a global variable \texttt{\_errno}, for accessing from code like \texttt{perror()}.
\end{itemize}

This procedure is illustrated in figure \ref{fig:tikz:int_handling} on page \pageref{fig:tikz:int_handling}.

\begin{figure}[]
  \centering
  % \includestandalone[]{obrazky-figures/mytikz}%     without .tex extension
  \input{obrazky-figures/mytikz}
  \caption{Interrupt handling in Linux}
  \label{fig:tikz:int_handling}
\end{figure}


\section{Monitoring}
The most used and common method for monitoring is tracing, in other words watching what a program is doing during the execution.
Tracing involves a specialized logging to record information, useful for debugging, about a program's execution.
This can be done in multiple layers, from tracing which lines in the program was executed to individual instructions executed on a CPU.
Collecting this information can be done with multiple tools, i.e, strace, ftrace and a lots of more.

\subsection{Strace -- trace system calls and signals}

Strace\cite{strace_man} is a simple diagnostic, instructional and debugging tool.
You can monitor every syscall or signal made by the program you are monitoring.
Using this tool, it is possible to log what an observed program demanded from the kernel.
The individual logged operations can be, i.e., an attempt to open a file or delete a content of CPU caches.
The strace also shows arguments for the called syscall.
Developer can perform a fault injection for the specified set of syscalls as well, to simulate the program in faulty test cases.
The next feature is that the Strace can trace child processes of the observing program.
The log on the output will be containing the system calls from the main process and its child processes.

The main advantage of Strace tool is that it does not need any source codes.
The observing program has not to be compiled with extra flags nor object files.
Also, it does not matter if the program is statically or dynamically linked.
% * <tamaskovic.marek@gmail.com> 2017-11-04T13:42:43.653Z:
% 
% Niesom si isty ako to povedat ale v podstate potrebujem len spustitelnu binarku.
% This is really useful because we do not need a custom binary to run strace with it.
% 
% ^.
This is really useful because we only need executable binary.
These features are really useful for my tool but this will be more described in another chapter.

This tool is really simple, i.e., when one want to run \texttt{ls} with strace he types in command line:\\
\\
\texttt{>\$ strace ls}\\
\\
In this case, the strace executes the \texttt{ls} command and on the output, it occurs which system calls were called.
An example of the strace output is in the next figure.\\[2mm]

\fontfamily{lmtt}\selectfont\noindent
execve("/usr/bin/ls", ["ls"], 0x7ffd0cf4ba60 /* 59 vars */) = 0\linebreak
open("/etc/ld.so.cache", O\_RDONLY|O\_CLOEXEC) = 3\linebreak
fstat(3, $\{$ st\_mode=S\_IFREG|0644, st\_size=202163, ...$\}$) = 0\linebreak
mmap(NULL, 202163, PROT\_READ, MAP\_PRIVATE, 3, 0) = 0x7fd781293000\linebreak
close(3)\linebreak
\fontfamily{\familydefault}\selectfont

\subsubsection{Ptrace}
Strace is using ptrace\cite{ptrace_man} system call.
The ptrace is used to  implement debuggers and other tools for process monitoring.
Basically the strace call ptrace and attach to a tracee (monitored process).
When the connection is established the tracee is halt before and after syscall.
Now the tracer (strace) can observe and control the execution as well as inspect memory and registers of (tracee).
With this information strace can determine which syscall was called.
With the second halt after syscall, the strace can get information of return value from syscall.

\subsection{Ftrace -- trace system calls, function calls and signals}
Ftrace\cite{ftrace_man} is an internal tracer which traces events in kernel.
It is designed for developers to examine kernel events. 
Main feature of this tool is to measure latencies and find issues that takes place outside of the user-space.
Ftrace is typically considered as a function tracker, but it is really a frame work of several different tracing utilities.
One cool feature of ftrace is measurement latency among interrupts, latency between the time when task is woken up and time when the task is scheduled in.
Other common use of ftrace is event tracing.
In the kernel is a huge amount of static event points that can be enabled with tracefs file system. 
The event points provide a interface to observe what is going on in the various part of kernel.

\subsection{Dtrace -- Dynamic Tracing}
DTrace\cite{dtrace_man}\cite{dtrace_about} (shortcut for Dynamic Tracing) is a performance analysis and troubleshooting tool.
It is included in various operating systems, including FreeBSD, Mac OS, Solaris and Linux port is in development.
This tool instruments all software, not just user-level software but also operating system kernel and device drivers.
It supports dynamic tracing which means dynamically patching while running instructions with an instrumentation code.
Static tracing is supported as well but it needs to add tracepoints to the code.
DTrace provides a scripting language called 'D' for writing scripts and one-liners.
It is similar to C with AWK elements.
With this script, you can create filters and summarize data in the kernel before passing to user-space.
This design can really decrease the overhead in performance sensitive systems.

For our purposes, DTrace is too complicated to setup or gather the information about syscalls.
You need to write some scripts to define which syscalls you want to be informed with and in our use case, we need every system call.

\subsection{Autrace -- linux audit}
The Linux Auditing System helps system administrators create an audit trail.
Every action on workstation or server is logged into log file.
This tool can track security relevant events, record the events and detect misuse or unauthorized activities by inspecting the audit log.
You can also set which actions should or should not be reported. 

Audit System is composed of two main parts.
The first one \(autrace\) is kernel component which intercept system calls, records event and sends these audit messages to the next part.
The second component is audit daemon.
This part of this tool is collecting the information emitted by kernel component.
Emitted information are then stored as entries in a log file.

As you can see this tool is not for monitoring one specific program but it is designed to monitor whole system.
In the output is specified who executed the syscall and when, next are current working directory, uid, gid, etc., \ldots
%Above specified functionality is useful for server administrators but not for our work.

Entry example in log file:

\noindent
\texttt{type=SYSCALL msg=audit(1434371271.277:135496): arch=c000003e syscall=2}\linebreak
\texttt{success=yes exit=3 a0=7fff0054e929 a1=0 a2=1fffffffffff0000 a3=7fff0054c390 }\linebreak
\texttt{items=1 ppid=6265pid=6266 auid=1000 uid=0 gid=0 euid=0 suid=0 fsuid=0 }\linebreak
\texttt{egid=0 sgid=0 fsgid=0 tty=pts0 ses=113 comm="cat" }\linebreak
\texttt{exe="/usr/bin/cat" key="sshconfigchange"}



\chapter{Security facility in Linux}

Systrace\cite{systrace_web} and seccomp\cite{seccomp_sandbox}

\section{Systrace}
Systrace is security facility which limits an application's access to the system.
It is really similar to a newer tool named seccomp-bpf, which is described later.
The limitations are provided via system call blocking. 
The policy is generated interactively.
Operations not covered by the defined policy raise an alarm.
When alarm is raised, user can refine the current policy.
Systrace provides option to generate policies automatically. 
These automatically generated policies can be immediately used in sandboxing.
But sometimes is needed minimal manual post-processing.

This tool provides cyber security by providing intrusion prevention. 
One of the use cases is that you run systrace on server.
The systrace is monitoring all running daemons and can generate warning when some incident occurs.
These warnings can be sent to a system administrator and can provide informations what happened.

\section{Seccomp}
In most contemporary distribution is enabled kernel module named Seccomp\cite{seccomp_sandbox}.
Seccomp stands for shortcut of Secure Computing Mode.
This module provide one way transition to a secure mode, which restricts a thread to a small amount of system calls \( \texttt{read()},\ \texttt{write()},\ \texttt{exit()},\ \texttt{sigreturn()}\ \).
If the thread tries to call other system call then the one from the 4 member set, the whole process is terminated with signal \texttt{SIGTERM} . 
The drawback of this solution is that these four system calls are not enough for application to run correctly.

\subsection{Seccomp-bpf}
\subsubsection{Berkeley packet filter}
\subsubsection{Classic BPF}
\subsubsection{Extended BPF}

\subsection{libseccomp}



\chapter{Design of TODO: tool-name}
\section{parser}
\section{optimizer}
\section{translator}



\chapter{Development of TODO: tool-name}
\section{Input}
\section{Intermediate representation}
\section{Output}
\section{Heuristics and optimizations}
\subsection{Minimax}
\subsection{Strict}
\subsection{Smart}


\chapter{Testing methods}


%=========================================================================
